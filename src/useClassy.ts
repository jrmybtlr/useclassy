import type { Plugin } from 'vite';
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';

// Supported file extensions
const SUPPORTED_FILES = ['.vue', '.ts', '.tsx', '.html', '.js', '.jsx'];

// Base constants
const CLASS_REGEX = /class="([^"]*)"(?![^>]*:class)/g;
const VUE_CLASS_MODIFIER_REGEX = /class:([\w-:]+)="([^"]*)"/g;
const MULTIPLE_CLASS_REGEX = /class="[^"]*"(\s*class="[^"]*")*/g;

// React-specific constants
const REACT_CLASS_REGEX = /className="([^"]*)"(?![^>]*:className)/g;
const REACT_CLASS_MODIFIER_REGEX = /class:([\w-:]+)="([^"]*)"/g;
const REACT_MULTIPLE_CLASS_REGEX = /className="[^"]*"(\s*className="[^"]*")*/g;

interface ClassyOptions {
  language?: 'vue' | 'react';
  outputDir?: string;
  outputFileName?: string;
}

interface ViteServer {
  watcher: {
    on: (event: string, callback: (filePath: string) => void) => void;
  };
  middlewares: {
    use: (path: string, handler: (req: any, res: any) => void) => void;
  };
  httpServer: {
    once: (event: string, callback: () => void) => void;
  } | null;
  transformRequest: (filePath: string) => Promise<any>;
}

/**
 * Generates a hash string from the input string
 */
export function hashString(str: string): string {
  return crypto.createHash('md5').update(str).digest('hex').substring(0, 8);
}

/**
 * Loads ignored directories from .gitignore
 */
function loadIgnoredDirectories(): string[] {
  const gitignorePath = path.join(process.cwd(), '.gitignore');
  if (!fs.existsSync(gitignorePath)) return [];

  try {
    const content = fs.readFileSync(gitignorePath, 'utf-8');
    return content
      .split('\n')
      .map(line => line.trim())
      .filter(line => line && !line.startsWith('#'))
      .filter(line => line.endsWith('/') || !line.includes('.'))
      .map(dir => dir.startsWith('/') ? dir.substring(1) : dir);
  } catch (error) {
    console.warn('Failed to read .gitignore file:', error);
    return [];
  }
}

/**
 * Checks if a file is in an ignored directory
 */
function isInIgnoredDirectory(filePath: string, ignoredDirectories: string[]): boolean {
  if (!ignoredDirectories.length) return false;
  
  const relativePath = path.relative(process.cwd(), filePath);
  return ignoredDirectories.some(dir => 
    relativePath.startsWith(dir + '/') || relativePath === dir
  );
}

/**
 * Updates .gitignore to exclude the output directory
 */
function writeGitignore(outputDir: string): void {
  const gitignorePath = path.join(process.cwd(), '.gitignore');
  const gitignoreEntry = `\n# Generated Classy files\n${outputDir}/\n`;

  try {
    if (fs.existsSync(gitignorePath)) {
      const currentContent = fs.readFileSync(gitignorePath, 'utf-8');
      if (!currentContent.includes(`${outputDir}/`)) {
        fs.appendFileSync(gitignorePath, gitignoreEntry);
      }
    } else {
      fs.writeFileSync(gitignorePath, gitignoreEntry.trim());
    }
  } catch (error) {
    console.warn('Failed to update .gitignore file:', error);
  }
}

/**
 * Writes the output file with all classes
 */
function writeOutputFile(allClassesSet: Set<string>, outputDir: string, outputFileName: string, isReact: boolean): void {
  try {
    // Create output directory if it doesn't exist
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Create .gitignore file inside output directory
    const classyGitignorePath = path.join(outputDir, '.gitignore');

    if (!fs.existsSync(classyGitignorePath)) {
      fs.writeFileSync(classyGitignorePath, '# Ignore all files in this directory\n*');
    }

    writeGitignore(outputDir);

    // Create a single file with all classes
    const outputFilePath = path.join(outputDir, outputFileName);
    const classAttrName = isReact ? 'className' : 'class';
    const jsxContent = `// Generated by useClassy
    export default function ClassyOutput() {
      return (
        <div>
          ${Array.from(allClassesSet).map(cls => `<div ${classAttrName}="${cls}" />`).join('\n      ')}
        </div>
      );
    }`;
    
    let shouldWrite = true;
    if (fs.existsSync(outputFilePath)) {
      const currentContent = fs.readFileSync(outputFilePath, 'utf-8');
      if (currentContent === jsxContent) {
        shouldWrite = false;
      }
    }
    
    // 
    // Create a temporary file to avoid triggering the file watcher
    // and then rename it to the actual file
    // 
    if (shouldWrite) {
      const tempFilePath = path.join(outputDir, `.${outputFileName}.tmp`);
      fs.writeFileSync(tempFilePath, jsxContent, { encoding: 'utf-8' });
      fs.renameSync(tempFilePath, outputFilePath);
    }
  } catch (error) {
    console.error('Failed to write classy output file:', error);
  }
}

/**
 * Use Classy plugin for Vite
 */
export default function useClassy(options: ClassyOptions = {}): Plugin {
  const outputDir = options.outputDir || '.classy';
  const outputFileName = options.outputFileName || 'output.classy.jsx';
  const transformCache: Map<string, string> = new Map();
  const ignoredDirectories = loadIgnoredDirectories();
  const allClassesSet: Set<string> = new Set();
  const isReact = options.language === 'react';

  // Use regex patterns based on framework
  const classRegex = isReact ? REACT_CLASS_REGEX : CLASS_REGEX;
  const classModifierRegex = isReact ? REACT_CLASS_MODIFIER_REGEX : VUE_CLASS_MODIFIER_REGEX;
  const multipleClassRegex = isReact ? REACT_MULTIPLE_CLASS_REGEX : MULTIPLE_CLASS_REGEX;
  const classAttrName = isReact ? 'className' : 'class';

  let needsOutputUpdate = false;
  let initialOutputWritten = false;
  let filesProcessed = 0;

  return {
    name: 'useClassy',
    enforce: 'pre',

    configureServer(server: ViteServer) {
      setupFileWatchers(server);
      setupOutputEndpoint(server);
      
      if (server.httpServer) {
        server.httpServer.once('listening', () => {
          if (needsOutputUpdate && !initialOutputWritten) {
            writeOutputFile(allClassesSet, outputDir, outputFileName, isReact);
            initialOutputWritten = true;
          }
        });
      }
    },

    transform(code: string, id: string) {
      if (!shouldProcessFile(id)) return;

      this.addWatchFile(id);
      const cacheKey = generateCacheKey(id, code);

      if (transformCache.has(cacheKey)) {
        return transformCache.get(cacheKey);
      }

      const result = processCode(code, allClassesSet);
      filesProcessed++;
      
      if (filesProcessed === 1 && !initialOutputWritten) {
        setTimeout(() => {
          writeOutputFile(allClassesSet, outputDir, outputFileName, isReact);
          initialOutputWritten = true;
        }, 0);
      }

      transformCache.set(cacheKey, result);
      return result;
    },
  };

  /**
   * Sets up file watchers for the server
   */
  function setupFileWatchers(server: ViteServer) {
    function isIgnored(filePath: string) {
      return filePath.endsWith('useClassy.ts') || filePath.includes('/.classy/output.classy.jsx') || !shouldProcessFile(filePath);
    }
    server.watcher.on('change', async (filePath: string) => {
      if (isIgnored(filePath)) return;
      const code = fs.readFileSync(filePath, 'utf-8');
      transformCache.delete(generateCacheKey(filePath, code));
      await server.transformRequest(filePath);
      needsOutputUpdate = true;
      writeOutputFile(allClassesSet, outputDir, outputFileName, isReact);
    });

    server.watcher.on('add', async (filePath: string) => {
      if (isIgnored(filePath)) return;
      await server.transformRequest(filePath);
      needsOutputUpdate = true;
      writeOutputFile(allClassesSet, outputDir, outputFileName, isReact);
    });
  }

  /**
   * Sets up the output endpoint for the server
   */
  function setupOutputEndpoint(server: ViteServer) {
    server.middlewares.use('/__useClassy__/generate-output', (_req: any, res: any) => {
      if (needsOutputUpdate) {
        writeOutputFile(allClassesSet, outputDir, outputFileName, isReact);
        needsOutputUpdate = false;
        res.statusCode = 200;
        res.end('Output file generated');
      } else {
        res.statusCode = 304;
        res.end('No changes to generate');
      }
    });
  }

  /**
   * Checks if a file should be processed
   */
  function shouldProcessFile(filePath: string): boolean {
    // Skip files with unsupported extensions
    if (!SUPPORTED_FILES.some((ext) => filePath?.split('?')[0]?.endsWith(ext))) return false;
    
    // Skip node_modules, virtual files, and runtime files
    if (filePath.includes('node_modules') || filePath.includes('\0')) return false;
    if (filePath.includes('virtual:') || filePath.includes('runtime')) return false;
    
    // Skip files in ignored directories
    if (isInIgnoredDirectory(filePath, ignoredDirectories)) return false;
    
    return true;
  }

  /**
   * Generates a cache key for a file
   */
  function generateCacheKey(id: string, code: string): string {
    return hashString(id + code);
  }

  /**
   * Processes the code to extract and transform classes
   */
  function processCode(code: string, allClassesSet: Set<string>): string {
    const generatedClassesSet: Set<string> = new Set();
    extractClasses(code, generatedClassesSet);

    generatedClassesSet.forEach(className => {
      if (className.includes(':')) allClassesSet.add(className);
    });

    return mergeClassAttributes(transformClassModifiers(code, generatedClassesSet), classAttrName);
  }

  /**
   * Extracts classes from the code
   */
  function extractClasses(code: string, generatedClassesSet: Set<string>): void {
    // Extract regular classes
    let classMatch;
    while ((classMatch = classRegex.exec(code)) !== null) {
      const classes = classMatch[1];
      if (classes) {
        classes.split(' ').forEach(cls => {
          if (cls.trim()) {
            generatedClassesSet.add(cls.trim());
          }
        });
      }
    }

    // Extract class modifiers
    let modifierMatch;
    while ((modifierMatch = classModifierRegex.exec(code)) !== null) {
      const modifiers = modifierMatch[1];
      const classes = modifierMatch[2];
      
      if (modifiers && classes) {
        const modifierParts = modifiers.split(':');
        
        classes.split(' ').forEach(cls => {
          if (cls.trim()) {
            // Add the full modifier:class combination
            generatedClassesSet.add(`${modifiers}:${cls.trim()}`);

            // Add individual modifier parts for better coverage
            if (modifierParts.length > 1) {
              modifierParts.forEach(part => {
                if (part) generatedClassesSet.add(`${part}:${cls.trim()}`);
              });
            }
          }
        });
      }
    }
  }

  /**
   * Transforms class modifiers in the code
   */
  function transformClassModifiers(code: string, generatedClassesSet: Set<string>): string {
    return code.replace(classModifierRegex, (match, modifiers, classes) => {
      if (!modifiers || modifiers.trim() === '') return match;
      
      const modifierParts = modifiers.split(':');
      
      // Process each modifier part
      const modifiedClassesArr = classes.split(' ')
        .map((value: string) => value.trim())
        .filter((value: string) => value && value !== '')
        .flatMap((value: string) => {
          // Create an array with the full modifier:class combination
          const result = [`${modifiers}:${value}`];
          
          // Also add individual modifier parts for better coverage
          if (modifierParts.length > 1) {
            modifierParts.forEach((part: string) => {
              if (part) {
                result.push(`${part}:${value}`);
              }
            });
          }
          
          return result;
        });
      
      // Add all modified classes to the set
      modifiedClassesArr.forEach((cls: string) => {
        if (cls && !cls.endsWith(':') && !cls.startsWith("'") && !cls.endsWith("'")) {
          generatedClassesSet.add(cls);
        }
      });

      return `${classAttrName}="${modifiedClassesArr.join(' ')}"`;
    });
  }

  /**
   * Merges multiple class attributes into a single one
   */
  function mergeClassAttributes(code: string, attrName: string): string {
    return code.replace(multipleClassRegex, (match) => {
      const allClasses = match
        .match(new RegExp(`${attrName}="([^"]*)"`, 'g'))
        ?.map(cls => {
          const subMatch = cls.match(new RegExp(`${attrName}="([^"]*)"`));
          return subMatch ? subMatch[1] : '';
        })
        .filter(Boolean)
        .join(' ') || '';

      return `${attrName}="${allClasses}"`;
    });
  }
}
