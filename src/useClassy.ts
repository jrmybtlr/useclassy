import type { Plugin } from 'vite';
import fs from 'fs';
import path from 'path';

// ===== Constants =====
const SUPPORTED_FILES = ['.vue', '.ts', '.tsx', '.html', '.js', '.jsx'];
const CLASS_REGEX = /class="([^"]*)"(?![^>]*:class)/g;
const CLASS_MODIFIER_REGEX = /class:([\w-:]+)="([^"]*)"/g;
const MULTIPLE_CLASS_REGEX = /class="[^"]*"(\s*class="[^"]*")*/g;
const PRE_TAG_REGEX = /<pre[^>]*>[\s\S]*?<\/pre>|<pre[^>]*v-html[^>]*\/?>/g;
const PRE_TAG_PLACEHOLDER_REGEX = /__PRE_TAG_(\d+)__/g;

// ===== Types =====
interface ClassyOptions {
  language?: 'vue' | 'react';
  outputDir?: string;
  outputFileName?: string;
}

interface ViteServer {
  watcher: {
    on: (event: string, callback: (filePath: string) => void) => void;
  };
  middlewares: {
    use: (path: string, handler: (req: any, res: any) => void) => void;
  };
  httpServer: {
    once: (event: string, callback: () => void) => void;
  } | null;
  transformRequest: (filePath: string) => Promise<any>;
}

// ===== Utility Functions =====
/**
 * Generates a hash string from the input string
 * @param str - The input string to hash
 * @returns A hash string
 */
export function hashString(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash.toString(36);
}

/**
 * Loads ignored directories from .gitignore
 * @returns Array of ignored directory paths
 */
function loadIgnoredDirectories(): string[] {
  const gitignorePath = path.join(process.cwd(), '.gitignore');
  if (!fs.existsSync(gitignorePath)) return [];

  try {
    const content = fs.readFileSync(gitignorePath, 'utf-8');
    return content
      .split('\n')
      .map(line => line.trim())
      .filter(line => line && !line.startsWith('#'))
      .filter(line => line.endsWith('/') || !line.includes('.'))
      .map(dir => dir.startsWith('/') ? dir.substring(1) : dir);
  } catch (error) {
    console.warn('Failed to read .gitignore file:', error);
    return [];
  }
}

/**
 * Checks if a file is in an ignored directory
 * @param filePath - The file path to check
 * @param ignoredDirectories - Array of ignored directory paths
 * @returns True if the file is in an ignored directory
 */
function isInIgnoredDirectory(filePath: string, ignoredDirectories: string[]): boolean {
  if (!ignoredDirectories.length) return false;
  
  const relativePath = path.relative(process.cwd(), filePath);
  return ignoredDirectories.some(dir => 
    relativePath.startsWith(dir + '/') || relativePath === dir
  );
}

/**
 * Updates .gitignore to exclude the output directory
 * @param outputDir - The output directory to exclude
 */
function updateGitignore(outputDir: string): void {
  const gitignorePath = path.join(process.cwd(), '.gitignore');
  const gitignoreEntry = `\n# Generated Classy files\n${outputDir}/\n`;

  try {
    if (fs.existsSync(gitignorePath)) {
      const currentContent = fs.readFileSync(gitignorePath, 'utf-8');
      if (!currentContent.includes(`${outputDir}/`)) {
        fs.appendFileSync(gitignorePath, gitignoreEntry);
      }
    } else {
      fs.writeFileSync(gitignorePath, gitignoreEntry.trim());
    }
  } catch (error) {
    console.warn('Failed to update .gitignore file:', error);
  }
}

/**
 * Writes the output file with all classes
 * @param allClassesSet - Set of all classes
 * @param outputDir - Output directory
 * @param outputFileName - Output file name
 */
function writeOutputFile(allClassesSet: Set<string>, outputDir: string, outputFileName: string): void {
  try {
    // Create output directory if it doesn't exist
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Create .gitignore file inside output directory
    const classyGitignorePath = path.join(outputDir, '.gitignore');
    if (!fs.existsSync(classyGitignorePath)) {
      fs.writeFileSync(classyGitignorePath, '# Ignore all files in this directory\n*');
    }

    // Update .gitignore to exclude output directory
    updateGitignore(outputDir);

    // Create a single file with all classes
    const outputFilePath = path.join(outputDir, outputFileName);
    const jsxContent = `// Generated by useClassy
export default function ClassyOutput() {
  return (
    <div>
      ${Array.from(allClassesSet).map(cls => `<div class="${cls}" />`).join('\n      ')}
    </div>
  );
}`;
    
    // Check if the file exists and has the same content to avoid unnecessary writes
    let shouldWrite = true;
    if (fs.existsSync(outputFilePath)) {
      const currentContent = fs.readFileSync(outputFilePath, 'utf-8');
      if (currentContent === jsxContent) {
        console.log(`[useClassy] Output file content unchanged, skipping write`);
        shouldWrite = false;
      }
    }
    
    if (shouldWrite) {
      // Use a temporary file to avoid triggering the file watcher
      const tempFilePath = path.join(outputDir, `.${outputFileName}.tmp`);
      fs.writeFileSync(tempFilePath, jsxContent, { encoding: 'utf-8' });
      
      // Rename the temporary file to the actual file
      fs.renameSync(tempFilePath, outputFilePath);
    }
  } catch (error) {
    console.error('Failed to write classy output file:', error);
  }
}

// ===== Main Plugin =====
/**
 * Use Classy plugin for Vite
 * @param options - Configuration options for the plugin
 * @returns The Vite plugin
 */
export default function useClassy(options: ClassyOptions = {}): Plugin {
  // Config
  const outputDir = options.outputDir || '.classy';
  const outputFileName = options.outputFileName || 'output.classy.jsx';
  const transformCache: Map<string, string> = new Map();
  const ignoredDirectories = loadIgnoredDirectories();
  const allClassesSet: Set<string> = new Set();

  let needsOutputUpdate = false;
  let initialOutputWritten = false;
  let filesProcessed = 0;

  return {
    name: 'useClassy',
    enforce: 'pre',

    configureServer(server: ViteServer) {
      setupFileWatchers(server);
      setupOutputEndpoint(server);
      
      if (server.httpServer) {
        server.httpServer.once('listening', () => {
          if (needsOutputUpdate && !initialOutputWritten) {
            writeOutputFile(allClassesSet, outputDir, outputFileName);
            initialOutputWritten = true;
          }
        });
      }
    },

    transform(code: string, id: string) {
      if (!shouldProcessFile(id)) return;

      this.addWatchFile(id);
      const cacheKey = generateCacheKey(id, code);

      if (transformCache.has(cacheKey)) {
        return transformCache.get(cacheKey);
      }

      const result = processCode(code, allClassesSet);
      filesProcessed++;
      
      if (filesProcessed === 1 && !initialOutputWritten) {
        setTimeout(() => {
          writeOutputFile(allClassesSet, outputDir, outputFileName);
          initialOutputWritten = true;
        }, 0);
      }

      transformCache.set(cacheKey, result);
      return result;
    },
  };

  /**
   * Sets up file watchers for the server
   * @param server - The Vite server
   */
  function setupFileWatchers(server: ViteServer) {
    server.watcher.on('change', async (filePath: string) => {
      if (filePath.endsWith('useClassy.ts') || filePath.includes('/.classy/output.classy.jsx')) return;
      if (!shouldProcessFile(filePath)) return;

      const code = fs.readFileSync(filePath, 'utf-8');
      transformCache.delete(generateCacheKey(filePath, code));
      await server.transformRequest(filePath);
      needsOutputUpdate = true;
      
      // Force immediate output update when a file changes
      writeOutputFile(allClassesSet, outputDir, outputFileName);
    });

    server.watcher.on('add', async (filePath: string) => {
      // Ignore the output file to prevent infinite loops
      if (filePath.endsWith('useClassy.ts') || filePath.includes('/.classy/output.classy.jsx')) return;

      if (!shouldProcessFile(filePath)) return;

      await server.transformRequest(filePath);
      needsOutputUpdate = true;
      
      // Force immediate output update when a new file is added
      writeOutputFile(allClassesSet, outputDir, outputFileName);
    });
  }

  /**
   * Sets up the output endpoint for the server
   * @param server - The Vite server
   */
  function setupOutputEndpoint(server: ViteServer) {
    server.middlewares.use('/__useClassy__/generate-output', (res: any) => {
      if (needsOutputUpdate) {
        writeOutputFile(allClassesSet, outputDir, outputFileName);
        needsOutputUpdate = false;
        res.statusCode = 200;
        res.end('Output file generated');
      } else {
        res.statusCode = 304;
        res.end('No changes to generate');
      }
    });
  }

  /**
   * Checks if a file should be processed
   * @param filePath - The file path to check
   * @returns True if the file should be processed
   */
  function shouldProcessFile(filePath: string): boolean {
    if (!SUPPORTED_FILES.some((ext) => filePath?.split('?')[0]?.endsWith(ext))) return false;
    if (filePath.includes('node_modules') || filePath.includes('\0')) return false;
    if (filePath.includes('virtual:') || filePath.includes('runtime')) return false;
    
    // Log when a file is skipped for debugging
    if (isInIgnoredDirectory(filePath, ignoredDirectories)) {
      console.log(`[useClassy] Skipping ignored file: ${filePath}`);
      return false;
    }
    
    return true;
  }

  /**
   * Generates a cache key for a file
   * @param id - The file ID
   * @param code - The file code
   * @returns The cache key
   */
  function generateCacheKey(id: string, code: string): string {
    return hashString(id + code);
  }

  /**
   * Processes the code to extract and transform classes
   * @param code - The code to process
   * @param allClassesSet - Set to store all classes
   * @returns The processed code
   */
  function processCode(code: string, allClassesSet: Set<string>): string {
    // Store pre tag content and replace with placeholders
    const preTagPlaceholders: string[] = [];
    let result = code.replace(PRE_TAG_REGEX, (match) => {
      preTagPlaceholders.push(match);
      return `__PRE_TAG_${preTagPlaceholders.length - 1}__`;
    });

    // Extract and transform classes
    const generatedClassesSet: Set<string> = new Set();
    extractClasses(code, generatedClassesSet);
    result = transformClassModifiers(result, generatedClassesSet);
    result = mergeClassAttributes(result);
    result = restorePreTags(result, preTagPlaceholders);

    // Add all found classes to the global set
    generatedClassesSet.forEach(cls => {
      if (cls.includes(':')) {
        allClassesSet.add(cls);
      }
    });

    return result;
  }

  /**
   * Extracts classes from the code
   * @param code - The code to extract classes from
   * @param generatedClassesSet - Set to store the extracted classes
   */
  function extractClasses(code: string, generatedClassesSet: Set<string>): void {
    // Extract regular classes
    let classMatch;
    while ((classMatch = CLASS_REGEX.exec(code)) !== null) {
      const classes = classMatch[1];
      if (classes) {
        classes.split(' ').forEach(cls => {
          if (cls.trim()) {
            generatedClassesSet.add(cls.trim());
          }
        });
      }
    }

    // Extract class modifiers
    let modifierMatch;
    while ((modifierMatch = CLASS_MODIFIER_REGEX.exec(code)) !== null) {
      const modifiers = modifierMatch[1];
      const classes = modifierMatch[2];
      
      if (modifiers && classes) {
        const modifierParts = modifiers.split(':');
        
        classes.split(' ').forEach(cls => {
          if (cls.trim()) {
            // Add the full modifier:class combination
            generatedClassesSet.add(`${modifiers}:${cls.trim()}`);

            // Add individual modifier parts for better coverage
            if (modifierParts.length > 1) {
              modifierParts.forEach(part => {
                if (part) generatedClassesSet.add(`${part}:${cls.trim()}`);
              });
            }
          }
        });
      }
    }
  }

  /**
   * Transforms class modifiers in the code
   * @param code - The code to transform
   * @param generatedClassesSet - Set to store the generated classes
   * @returns The transformed code
   */
  function transformClassModifiers(code: string, generatedClassesSet: Set<string>): string {
    return code.replace(CLASS_MODIFIER_REGEX, (match, modifiers, classes) => {
      if (!modifiers || modifiers.trim() === '') return match;
      
      const modifierParts = modifiers.split(':');
      
      // Process each modifier part
      const modifiedClassesArr = classes.split(' ')
        .map((value: string) => value.trim())
        .filter((value: string) => value && value !== '')
        .flatMap((value: string) => {
          // Create an array with the full modifier:class combination
          const result = [`${modifiers}:${value}`];
          
          // Also add individual modifier parts for better coverage
          if (modifierParts.length > 1) {
            modifierParts.forEach((part: string) => {
              if (part) {
                result.push(`${part}:${value}`);
              }
            });
          }
          
          return result;
        });
      
      // Add all modified classes to the set
      modifiedClassesArr.forEach((cls: string) => {
        if (cls && !cls.endsWith(':') && !cls.startsWith("'") && !cls.endsWith("'")) {
          generatedClassesSet.add(cls);
        }
      });

      return `class="${modifiedClassesArr.join(' ')}"`;
    });
  }

  /**
   * Merges multiple class attributes into a single one
   * @param code - The code to merge class attributes in
   * @returns The code with merged class attributes
   */
  function mergeClassAttributes(code: string): string {
    return code.replace(MULTIPLE_CLASS_REGEX, (match) => {
      const allClasses = match
        .match(/class="([^"]*)"/g)
        ?.map(cls => {
          const subMatch = cls.match(/class="([^"]*)"/);
          return subMatch ? subMatch[1] : '';
        })
        .filter(Boolean)
        .join(' ') || '';

      return `class="${allClasses}"`;
    });
  }

  /**
   * Restores pre tags in the code
   * @param code - The code to restore pre tags in
   * @param preTagPlaceholders - Array of pre tag placeholders
   * @returns The code with restored pre tags
   */
  function restorePreTags(code: string, preTagPlaceholders: string[]): string {
    return code.replace(PRE_TAG_PLACEHOLDER_REGEX, (_, index) => {
      return preTagPlaceholders[parseInt(index)] || '';
    });
  }
}