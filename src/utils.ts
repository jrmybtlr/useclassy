import fs from "fs";
import path from "path";
import { SUPPORTED_FILES } from "./core";

/**
 * Simple hash function for string values
 */
export function hashFunction(str: string): number {
  return str.split("").reduce((a, b) => {
    a = (a << 5) - a + b.charCodeAt(0);
    return a & a;
  }, 0);
}

/**
 * Load directories to ignore from .gitignore file
 */
export function loadIgnoredDirectories(): string[] {
  try {
    const gitignorePath = path.join(process.cwd(), ".gitignore");
    if (!fs.existsSync(gitignorePath)) {
      return ["node_modules", "dist"];
    }

    const gitignoreContent = fs.readFileSync(gitignorePath, "utf-8");
    return gitignoreContent
      .split("\n")
      .map((line) => line.trim())
      .filter(
        (line) =>
          line &&
          !line.startsWith("#") &&
          !line.includes("*") &&
          !line.startsWith("!")
      );
  } catch (error) {
    console.warn(
      "Could not load .gitignore file. Using default ignore patterns."
    );
    return ["node_modules", "dist"];
  }
}

/**
 * Add output directory to .gitignore
 */
export function writeGitignore(outputDir: string): void {
  const gitignorePath = path.join(process.cwd(), ".gitignore");
  const gitignoreEntry = `\n# Generated Classy files\n${outputDir}/\n`;

  try {
    if (fs.existsSync(gitignorePath)) {
      const currentContent = fs.readFileSync(gitignorePath, "utf-8");
      if (!currentContent.includes(`${outputDir}/`)) {
        fs.appendFileSync(gitignorePath, gitignoreEntry);
      }
    } else {
      fs.writeFileSync(gitignorePath, gitignoreEntry.trim());
    }
  } catch (error) {
    console.warn("Failed to update .gitignore file:", error);
  }
}

/**
 * Check if a file is in an ignored directory
 */
export function isInIgnoredDirectory(
  filePath: string,
  ignoredDirectories: string[]
): boolean {
  if (!ignoredDirectories.length) return false;
  const relativePath = path.relative(process.cwd(), filePath);
  return ignoredDirectories.some(
    (dir) => relativePath.startsWith(dir + "/") || relativePath === dir
  );
}

/**
 * Write the output file with all collected classes
 */
export function writeOutputFile(
  allClassesSet: Set<string>,
  outputDir: string,
  outputFileName: string,
  isReact: boolean
): void {
  try {
    const allClasses = Array.from(allClassesSet).filter(
      (cls) => cls && cls.includes(":")
    );

    if (allClasses.length === 0) {
      return;
    }

    const dirPath = path.join(process.cwd(), outputDir);
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }

    // Create .gitignore file inside output directory
    const classyGitignorePath = path.join(dirPath, ".gitignore");
    if (!fs.existsSync(classyGitignorePath)) {
      fs.writeFileSync(
        classyGitignorePath,
        "# Ignore all files in this directory\n*"
      );
    }

    // Update project .gitignore to include output directory
    writeGitignore(outputDir);

    const filePath = path.join(dirPath, outputFileName);
    const classesFormatted = allClasses.map((cls) => `'${cls}'`).join(",\n  ");

    const fileContent = `// Auto-generated by useClassy
<div class="${allClasses.join(" ")}" style="display: none;"/>
`;

    // Create a temporary file to avoid triggering the file watcher
    // and then rename it to the actual file
    const tempFilePath = path.join(dirPath, `.${outputFileName}.tmp`);
    fs.writeFileSync(tempFilePath, fileContent, { encoding: "utf-8" });
    fs.renameSync(tempFilePath, filePath);
  } catch (error) {
    console.error("Error writing output file:", error);
  }
}

/**
 * Determine if a file should be processed
 */
export function shouldProcessFile(
  filePath: string,
  ignoredDirectories: string[]
): boolean {
  // Skip files in ignored directories
  if (isInIgnoredDirectory(filePath, ignoredDirectories)) {
    return false;
  }

  // Skip files with unsupported extensions
  if (!SUPPORTED_FILES.some((ext) => filePath?.endsWith(ext))) {
    return false;
  }

  // Skip node_modules, virtual files, and null bytes
  if (filePath.includes("node_modules") || filePath.includes("\0")) {
    return false;
  }

  // Skip virtual files and runtime files
  if (filePath.includes("virtual:") || filePath.includes("runtime")) {
    return false;
  }

  return true;
}
